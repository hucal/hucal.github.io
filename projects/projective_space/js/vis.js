// Generated by CoffeeScript 1.9.2
var PI, add_to, camera, camera_far, canvas_circ, canvas_draw, canvas_line, canvas_rect, container, controls, i, j, k, l, len, len1, make_line, make_p_line, make_p_point, make_plane, make_point, max, obj, r2, r2_, r2_canvas, r2_context, r2_objects, r2_resolution, r2_texture, ref, render, renderer, root_objects, s2, s2_objects, scene, theta, to_canvas_color, to_ctx_coords, transform, vec3, vec3_from_array, x;

if (!Detector.webgl) {
  Detector.addGetWebGLMessage;
}

container = document.getElementById('vis');

scene = new THREE.Scene;

scene.fog = new THREE.FogExp2(0xffffff, 0.002);

camera_far = 10000;

camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, camera_far);

renderer = new THREE.WebGLRenderer({
  antialias: true
});

renderer.setSize(container.offsetWidth, container.offsetHeight);

renderer.setClearColor(scene.fog.color, 1);

renderer.setPixelRatio(window.devicePixelRatio);

container.appendChild(renderer.domElement);

window.addEventListener('resize', function() {
  camera.aspect = container.offsetWidth / container.offsetHeight;
  camera.updateProjectionMatrix();
  return renderer.setSize(container.offsetWidth, container.offsetHeight);
});

r2_canvas = document.createElement('canvas');

r2_resolution = 1024;

r2_canvas.width = r2_canvas.height = r2_resolution;

r2_context = r2_canvas.getContext('2d');

canvas_draw = function(ctx, obj) {
  var col;
  ctx.beginPath();
  col = obj.color ? obj.color : "#000";
  if (obj.should_stroke) {
    ctx.lineWidth = obj.lineWidth ? obj.lineWidth : 2;
    ctx.strokeStyle = col;
    ctx.stroke(obj);
  } else {
    ctx.fillStyle = col;
    ctx.fill(obj);
  }
  return ctx.closePath();
};


/* utility functions */

PI = Math.PI;

vec3 = function(x, y, z) {
  return new THREE.Vector3(x, y, z);
};

vec3_from_array = function(p) {
  return vec3(p[0], p[1], p.length > 2 ? p[2] : 1);
};

add_to = function(c, o) {
  c.push(o);
  return o;
};

make_point = function(collection, size, color, opacity, detail) {
  if (opacity == null) {
    opacity = 1.0;
  }
  if (detail == null) {
    detail = 15;
  }
  return add_to(collection, new THREE.Mesh(new THREE.SphereGeometry(size, detail, detail), new THREE.MeshLambertMaterial({
    color: color,
    transparent: opacity !== 1.0,
    opacity: opacity
  })));
};

make_plane = function(collection, size, color, opacity) {
  if (opacity == null) {
    opacity = 1.0;
  }
  return add_to(collection, new THREE.Mesh(new THREE.PlaneGeometry(size, size), new THREE.MeshBasicMaterial({
    color: color,
    side: THREE.DoubleSide,
    transparent: opacity !== 1.0,
    opacity: opacity
  })));
};

make_line = function(collection, here, there, color, width, extend) {
  var geometry, v1, v1_orig, v2;
  if (width == null) {
    width = 1;
  }
  if (extend == null) {
    extend = true;
  }
  v1 = here instanceof THREE.Vector3 ? here : vec3_from_array(here);
  v2 = there instanceof THREE.Vector3 ? there : vec3_from_array(there);
  if (extend) {
    v1_orig = v1.clone();
    v1.sub(v2);
    v1.setLength(camera_far);
    v1.add(v2);
    v2.sub(v1_orig);
    v2.setLength(camera_far);
    v2.add(v1_orig);
  }
  geometry = new THREE.Geometry;
  geometry.vertices.push(v1, v2);
  return add_to(collection, new THREE.Line(geometry, new THREE.LineBasicMaterial({
    color: color,
    linewidth: width
  })));
};

to_ctx_coords = function(xy, f) {
  return f(r2_resolution / 2 * (xy[0] + 1), r2_resolution / 2 * (1 - xy[1]));
};

make_p_point = function(x, y, color) {
  var c1, o1, o2, o3;
  c1 = canvas_circ(r2_objects, x, y, color, 6);
  o1 = make_line(root_objects, [-x, -y, -1], [x, y, 1], color);
  o2 = make_point(s2_objects, 0.0075, color);
  o2.position.copy(vec3(x, y, 1).normalize());
  o3 = make_point(s2_objects, 0.0075, color);
  o3.position.copy(vec3(-x, -y, -1).normalize());
  return [[c1], [o1, o2, o3]];
};

to_canvas_color = function(c) {
  if (c instanceof String || typeof c === "string") {
    return c;
  } else {
    return '#' + c.toString(16);
  }
};

canvas_rect = function(collection, start, end, color) {
  var c;
  c = add_to(collection, new Path2D());
  c.color = to_canvas_color(color);
  to_ctx_coords(start, function(x1, y1) {
    return to_ctx_coords(end, function(x2, y2) {
      return c.rect(x1 + 0.5, y1 + 0.5, x2 - x1, y2 - y1);
    });
  });
  return c;
};

canvas_circ = function(collection, x, y, color, radius) {
  var c;
  c = add_to(collection, new Path2D());
  c.color = to_canvas_color(color);
  to_ctx_coords([x, y], function(x, y) {
    return c.arc(x + 0.5, y + 0.5, radius, 0, 2 * PI);
  });
  return c;
};

canvas_line = function(collection, p1, p2, color, width) {
  var c;
  c = add_to(collection, new Path2D());
  c.color = to_canvas_color(color);
  c.should_stroke = true;
  c.lineWidth = width;
  to_ctx_coords(p1, function(x, y) {
    return c.moveTo(x, y);
  });
  to_ctx_coords(p2, function(x, y) {
    return c.lineTo(x + 0.5, y + 0.5);
  });
  return c;
};

make_p_line = function(p1, p2, color, opacity, draw_points) {
  var angle, c, o, v1, v2;
  if (opacity == null) {
    opacity = 1.0;
  }
  if (draw_points == null) {
    draw_points = false;
  }
  o = make_plane(root_objects, 3, color, opacity);
  v1 = vec3(p1[0], p1[1], 1);
  v2 = vec3(p2[0], p2[1], 1);
  c = canvas_line(r2_objects, p1, p2, color, 14);
  if (draw_points) {
    make_p_point(p1[0], p1[1], color);
    make_p_point(p2[0], p2[1], color);
  }
  v1.cross(v2);
  v1.normalize();
  angle = v1.angleTo(vec3(0, 0, 1));
  o.rotation.setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(vec3(0, 0, 1), v1));
  return [c, o];
};


/* setup scene */

r2_objects = [];

s2_objects = [];

root_objects = [];

canvas_rect(r2_objects, [-1, -1], [1, 1], "rgba(255, 255, 255, 0)");

max = 20;

for (i = j = 0, ref = max; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
  x = 1 - 2 * i / max;
  canvas_line(r2_objects, [x, 1], [x, -1], "black", 2);
  canvas_line(r2_objects, [1, x], [-1, x], "black", 2);
}

make_plane(root_objects, 2, 0xbbffbb);

make_p_point(0, 0, 0xff0000);

make_p_point(0.5, 0.5, 0xff0000);

make_p_line([0.2, 0.2], [-0.3, 0.4], 0xff00ff, 0.5, true);

make_p_line([-0.2, -0.2], [0.3, -0.3], 0xffffff, 0.5, true);

s2 = make_point(s2_objects, 1, 0xffffff, 0.2, 90);

r2_texture = new THREE.Texture(r2_canvas);

r2_texture.needsUpdate = true;

r2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({
  color: 0xffffff,
  side: THREE.DoubleSide,
  map: r2_texture,
  transparent: true
}));

r2.position.z = 1;

r2_ = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({
  side: THREE.DoubleSide,
  map: r2_texture,
  transparent: true
}));

transform = (new THREE.Matrix4).set(2, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1);

r2_.applyMatrix(transform);

r2_.position.z = 2;

scene.add(r2);

for (k = 0, len = root_objects.length; k < len; k++) {
  obj = root_objects[k];
  scene.add(obj);
}

for (l = 0, len1 = r2_objects.length; l < len1; l++) {
  obj = r2_objects[l];
  canvas_draw(r2_context, obj);
}

scene.add(new THREE.AmbientLight(0x404040));

scene.add(new THREE.HemisphereLight(0xffffff, 0x404040, 1));

controls = new THREE.OrbitControls(camera, renderer.domElement);

controls.enableDamping = true;

controls.dampingFactor = 0.1;

camera.position.z = 2;

theta = -PI * 3 / 4;

camera.position.y = 3 * Math.sin(theta);

camera.position.x = 3 * Math.cos(theta);

render = function() {
  requestAnimationFrame(render);
  renderer.render(scene, camera);
  return controls.update();
};

render();

//# sourceMappingURL=vis.js.map
